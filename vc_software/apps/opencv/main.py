#!/usr/bin/env python3
"""Main entrypoint for the Raspberry Pi LKAS vision node."""

from __future__ import annotations

import argparse
import json
import logging
import os
import socket
import sys
import time
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Any, List, Optional, Tuple

import cv2
import numpy as np

try:
    from picamera2 import Picamera2
except ImportError:  # pragma: no cover - optional dependency
    Picamera2 = None

from calibration import LaneCalibration
from lane_analyzer import LaneAnalyzer
from pipeline import VisionPipeline
from reporter import StatusReporter

FRAME_WIDTH = 1920
FRAME_HEIGHT = 1080
TARGET_FPS = 15
IMAGE_EXTENSIONS = {".jpg", ".jpeg", ".png", ".bmp"}

LIBCAMERA_PIPELINE = (
    f"libcamerasrc ! video/x-raw,format=YUY2,width={FRAME_WIDTH},height={FRAME_HEIGHT},"
    f"framerate={TARGET_FPS}/1 ! videoconvert ! video/x-raw,format=BGR ! "
    "appsink drop=1 max-buffers=1 sync=false"
)


@dataclass
class FrameProvider:
    """Abstraction over camera, video file, or image directory inputs."""

    mode: str
    label: str
    capture: Optional[cv2.VideoCapture] = None
    picam2: Any | None = None
    attempt_log: List[str] = field(default_factory=list)
    primed_frame: Optional[np.ndarray] = None
    image_paths: List[Path] = field(default_factory=list)
    image_index: int = 0
    loop_images: bool = False

    def read(self) -> Tuple[bool, Optional[np.ndarray]]:
        """Retrieve the next frame from the configured source."""
        if self.mode in {"camera", "video"}:
            if self.primed_frame is not None:
                frame = self.primed_frame
                self.primed_frame = None
                return True, frame
            if self.capture is None:
                return False, None
            return self.capture.read()

        if self.mode == "picamera2":
            if self.primed_frame is not None:
                frame = self.primed_frame
                self.primed_frame = None
                return True, frame
            if self.picam2 is None:
                return False, None
            frame = self.picam2.capture_array()
            if frame is None:
                return False, None
            frame_bgr = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
            return True, frame_bgr

        if self.mode == "images":
            total = len(self.image_paths)
            if total == 0:
                return False, None

            attempts = 0
            while attempts < total:
                if self.image_index >= total:
                    if self.loop_images:
                        self.image_index = 0
                    else:
                        return False, None

                path = self.image_paths[self.image_index]
                self.image_index += 1
                frame = cv2.imread(str(path))
                if frame is not None:
                    return True, frame

                attempts += 1
            return False, None

        return False, None

    def release(self) -> None:
        """Release any underlying capture resources."""
        if self.capture is not None:
            self.capture.release()
            self.capture = None
        if self.picam2 is not None:
            try:
                self.picam2.stop()
            except Exception:  # pragma: no cover - best effort
                pass
            try:
                self.picam2.close()
            except Exception:  # pragma: no cover - best effort
                pass
            self.picam2 = None


def parse_args() -> argparse.Namespace:
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(description="LKAS vision processing node.")
    parser.add_argument("--camera-index", type=int, default=0, help="V4L2 camera index to try before GStreamer.")
    parser.add_argument("--log-interval", type=float, default=0.5, help="Seconds between status logs.")
    parser.add_argument("--summary-window", type=int, default=60, help="Rolling window size for reporter metrics.")
    parser.add_argument("--ema-alpha", type=float, default=0.2, help="EMA smoothing factor for offset.")
    parser.add_argument("--frame-timeout", type=float, default=2.0, help="Fail if no frame captured within this window.")
    parser.add_argument("--udp-host", default="127.0.0.1", help="Realtime controller UDP host.")
    parser.add_argument("--udp-port", type=int, default=6000, help="Realtime controller UDP port.")
    parser.add_argument(
        "--calibration-file",
        default="calibration.json",
        help="Optional path to calibration.json generated by calibrate_lane.py.",
    )
    parser.add_argument(
        "--log-level",
        default="INFO",
        choices=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
        help="Log verbosity for the node.",
    )
    parser.add_argument("--video-path", help="Optional video file path to replay instead of a live camera.")
    parser.add_argument(
        "--image-dir",
        help="Optional directory of images to loop over instead of a live camera (sorted lexicographically).",
    )
    parser.add_argument(
        "--image-loop",
        action="store_true",
        help="Loop image directory inputs instead of stopping at the end.",
    )
    parser.add_argument(
        "--max-frames",
        type=int,
        default=0,
        help="Stop the program after processing this many frames (0 means run indefinitely).",
    )
    parser.add_argument(
        "--camera-backend",
        choices=["auto", "picamera2", "opencv"],
        default="auto",
        help="Preferred backend for live capture (auto tries Picamera2 first when available).",
    )
    parser.add_argument(
        "--telemetry-log",
        help="Optional path to append outgoing telemetry as JSON lines for offline analysis.",
    )
    parser.add_argument(
        "--run-tag",
        help="Optional label describing this run (stored in telemetry/log files).",
    )
    return parser.parse_args()


def configure_logging(level: str) -> logging.Logger:
    """Configure the root logger and return a module logger."""
    logging.basicConfig(
        level=getattr(logging, level.upper(), logging.INFO),
        format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
    )
    return logging.getLogger("lkas")


def configure_camera_capture(index: int, logger: logging.Logger) -> FrameProvider:
    """Initialise camera capture, trying V4L2 first and falling back to libcamera."""
    attempt_log: List[str] = []

    def _attempt_v4l2() -> Tuple[Optional[cv2.VideoCapture], Optional[np.ndarray]]:
        cap = cv2.VideoCapture(index)
        if not cap.isOpened():
            attempt_log.append(f"V4L2:/dev/video{index}: failed to open stream")
            cap.release()
            return None, None

        cap.set(cv2.CAP_PROP_FRAME_WIDTH, FRAME_WIDTH)
        cap.set(cv2.CAP_PROP_FRAME_HEIGHT, FRAME_HEIGHT)
        cap.set(cv2.CAP_PROP_FPS, TARGET_FPS)
        cap.set(cv2.CAP_PROP_BUFFERSIZE, 1)

        ret, frame = cap.read()
        if not ret or frame is None:
            attempt_log.append(f"V4L2:/dev/video{index}: opened but produced no frames")
            cap.release()
            return None, None

        actual_w = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
        actual_h = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
        attempt_log.append(f"V4L2:/dev/video{index}: success ({actual_w}x{actual_h})")
        return cap, frame

    def _attempt_libcamera() -> Tuple[Optional[cv2.VideoCapture], Optional[np.ndarray]]:
        cap = cv2.VideoCapture(LIBCAMERA_PIPELINE, cv2.CAP_GSTREAMER)
        if not cap.isOpened():
            attempt_log.append("libcamerasrc GStreamer: failed to open stream")
            cap.release()
            return None, None

        cap.set(cv2.CAP_PROP_OPEN_TIMEOUT_MSEC, 2000)
        cap.set(cv2.CAP_PROP_READ_TIMEOUT_MSEC, 2000)

        ret, frame = cap.read()
        if not ret or frame is None:
            attempt_log.append("libcamerasrc GStreamer: opened but produced no frames")
            cap.release()
            return None, None

        attempt_log.append("libcamerasrc GStreamer: success")
        return cap, frame

    cap, frame = _attempt_v4l2()
    source_label = f"/dev/video{index}"
    if cap is None:
        cap, frame = _attempt_libcamera()
        source_label = "libcamerasrc"

    if cap is None:
        logger.error("Unable to initialise camera. Attempts: %s", "; ".join(attempt_log))
        return FrameProvider(mode="camera", label="uninitialised", capture=None, attempt_log=attempt_log)

    logger.info("Camera initialised using %s", source_label)
    for entry in attempt_log:
        logger.debug("Capture attempt: %s", entry)

    return FrameProvider(
        mode="camera",
        label=source_label,
        capture=cap,
        attempt_log=attempt_log,
        primed_frame=frame,
    )


def create_video_provider(path: Path, logger: logging.Logger) -> FrameProvider:
    """Create a frame provider backed by a local video file."""
    if not path.exists():
        logger.critical("Video file %s does not exist.", path)
        sys.exit(1)

    cap = cv2.VideoCapture(str(path))
    if not cap.isOpened():
        logger.critical("Failed to open video file: %s", path)
        sys.exit(1)

    cap.set(cv2.CAP_PROP_FRAME_WIDTH, FRAME_WIDTH)
    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, FRAME_HEIGHT)
    cap.set(cv2.CAP_PROP_FPS, TARGET_FPS)

    ret, frame = cap.read()
    if not ret or frame is None:
        cap.release()
        logger.critical("Video file %s could not provide an initial frame.", path)
        sys.exit(1)

    logger.info("Video source initialised from %s", path)
    return FrameProvider(mode="video", label=str(path), capture=cap, primed_frame=frame)


def create_image_provider(directory: Path, loop_images: bool, logger: logging.Logger) -> FrameProvider:
    """Create a frame provider backed by a directory of still images."""
    if not directory.exists():
        logger.critical("Image directory %s does not exist.", directory)
        sys.exit(1)
    if not directory.is_dir():
        logger.critical("%s is not a directory.", directory)
        sys.exit(1)

    paths = sorted(
        [path for path in directory.iterdir() if path.suffix.lower() in IMAGE_EXTENSIONS]
    )
    if not paths:
        logger.critical("Image directory %s contains no supported files.", directory)
        sys.exit(1)

    logger.info("Image directory source initialised (%d files, loop=%s).", len(paths), loop_images)
    return FrameProvider(
        mode="images",
        label=str(directory),
        image_paths=paths,
        loop_images=loop_images,
    )


def create_picamera2_provider(logger: logging.Logger) -> FrameProvider:
    """Initialise a Picamera2 streaming source."""
    if Picamera2 is None:
        raise RuntimeError("Picamera2 module is not installed.")

    picam2: Picamera2 | None = None
    try:
        picam2 = Picamera2()
        video_config = picam2.create_video_configuration(
            main={"size": (FRAME_WIDTH, FRAME_HEIGHT)},
            controls={"FrameRate": TARGET_FPS},
        )
        picam2.configure(video_config)
        picam2.start()
        time.sleep(1.0)
        frame = picam2.capture_array()
        if frame is None:
            raise RuntimeError("Picamera2 returned no initial frame.")
        primed = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
    except Exception as exc:  # pragma: no cover - hardware path
        if picam2 is not None:
            try:
                picam2.close()
            except Exception:
                pass
        raise RuntimeError(f"Failed to initialise Picamera2: {exc}") from exc

    logger.info(
        "Picamera2 backend initialised (%dx%d @ %dfps).",
        FRAME_WIDTH,
        FRAME_HEIGHT,
        TARGET_FPS,
    )
    return FrameProvider(mode="picamera2", label="picamera2", picam2=picam2, primed_frame=primed)


def initialise_frame_provider(args: argparse.Namespace, logger: logging.Logger) -> FrameProvider:
    """Select the correct frame provider based on CLI flags."""
    if args.image_dir:
        return create_image_provider(Path(args.image_dir), args.image_loop, logger)
    if args.video_path:
        return create_video_provider(Path(args.video_path), logger)

    backend = args.camera_backend
    if backend == "picamera2":
        try:
            return create_picamera2_provider(logger)
        except RuntimeError as exc:
            logger.critical("%s", exc)
            sys.exit(1)
    if backend == "opencv":
        return configure_camera_capture(args.camera_index, logger)

    if Picamera2 is not None:
        try:
            return create_picamera2_provider(logger)
        except RuntimeError as exc:
            logger.warning("Picamera2 backend unavailable, falling back to OpenCV: %s", exc)
    return configure_camera_capture(args.camera_index, logger)


def open_telemetry_log(path_str: Optional[str], logger: logging.Logger) -> Optional[Path]:
    """Determine the telemetry log path, ensuring directories exist."""
    if path_str:
        log_path = Path(path_str)
    else:
        log_dir = Path("logs")
        log_dir.mkdir(parents=True, exist_ok=True)
        for old_file in log_dir.glob("vision_*.jsonl"):
            try:
                old_file.unlink()
            except OSError:
                pass
        log_path = log_dir / "vision_latest.jsonl"

    try:
        if log_path.exists():
            log_path.unlink()
        if log_path.parent:
            log_path.parent.mkdir(parents=True, exist_ok=True)
        log_path.touch()
        try:
            os.chmod(log_path, 0o666)
        except OSError:
            logger.warning("Failed to update permissions on %s", log_path)
        logger.info("Telemetry log enabled: %s", log_path)
        return log_path
    except OSError as exc:
        logger.error("Failed to prepare telemetry log %s: %s", log_path, exc)
        return None


def main() -> None:
    """Run the LKAS vision node."""
    args = parse_args()
    logger = configure_logging(args.log_level)

    calibration: LaneCalibration | None = None
    if args.calibration_file:
        calib_path = Path(args.calibration_file)
        if calib_path.exists():
            try:
                calibration = LaneCalibration.from_file(calib_path)
                logger.info(
                    "Loaded calibration (%s): lane_width_px=%.1f cm_per_pixel=%.4f",
                    calib_path,
                    calibration.lane_width_px,
                    calibration.cm_per_pixel,
                )
            except (OSError, ValueError, KeyError, json.JSONDecodeError) as exc:
                logger.warning("Failed to load calibration file %s: %s", calib_path, exc)
        else:
            logger.info("Calibration file %s not found; using default parameters.", calib_path)

    frame_provider = initialise_frame_provider(args, logger)
    if frame_provider.mode == "camera" and frame_provider.capture is None:
        logger.critical("Camera initialisation failed; aborting.")
        sys.exit(1)

    telemetry_log_file = None
    telemetry_log_path = open_telemetry_log(args.telemetry_log, logger)
    if telemetry_log_path is not None:
        try:
            telemetry_log_file = telemetry_log_path.open("a", encoding="utf-8")
        except OSError as exc:
            logger.error("Failed to open telemetry log %s: %s", telemetry_log_path, exc)

    analyzer = LaneAnalyzer(frame_width=FRAME_WIDTH, frame_height=FRAME_HEIGHT, calibration=calibration)
    pipeline = VisionPipeline(
        analyzer=analyzer,
        frame_width=FRAME_WIDTH,
        frame_height=FRAME_HEIGHT,
        target_fps=TARGET_FPS,
    )
    reporter = StatusReporter(
        alpha=args.ema_alpha,
        log_interval=args.log_interval,
        window_size=args.summary_window,
        logger=logging.getLogger("lkas.reporter"),
    )
    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    udp_target = (args.udp_host, args.udp_port)
    last_frame_monotonic = time.monotonic()
    frame_counter = 0

    try:
        while True:
            ret, frame = frame_provider.read()

            if not ret or frame is None:
                if frame_provider.mode in {"camera", "picamera2"}:
                    elapsed = time.monotonic() - last_frame_monotonic
                    if elapsed > args.frame_timeout:
                        logger.error("Camera read timed out after %.2f seconds", elapsed)
                        break
                    time.sleep(0.01)
                    continue

                logger.info("Frame source %s exhausted; stopping.", frame_provider.label)
                break

            last_frame_monotonic = time.monotonic()
            frame_counter += 1
            processed = pipeline.process(frame)
            processed = reporter.update(processed)

            offset_value = processed.get("offset_smoothed", processed.get("offset"))
            logger.debug(
                "analysis offset=%s lane=%s stop=%s conf=%s fps=%.1f latency=%.1fms",
                "N/A" if offset_value is None else f"{float(offset_value):+.3f}",
                processed.get("lane_state"),
                bool(processed.get("stop_detected")),
                f"{float(processed.get('confidence') or 0.0):.2f}",
                float(processed.get("fps") or 0.0),
                float(processed.get("latency_ms") or 0.0),
            )

            payload = {
                "offset": processed.get("offset"),
                "offset_cm": processed.get("offset_cm"),
                "offset_px": processed.get("offset_px"),
                "lane_state": processed.get("lane_state"),
                "stop_detected": bool(processed.get("stop_detected")),
                "confidence": processed.get("confidence"),
                "timestamp": processed.get("timestamp"),
                "curve_hint": processed.get("curve_hint"),
                "curve_phase": processed.get("curve_phase"),
                "curve_scope": processed.get("curve_scope"),
                "lane_visibility": processed.get("lane_visibility"),
                "release_debug": processed.get("release_debug"),
            }
            if args.run_tag:
                payload["run_tag"] = args.run_tag
            if telemetry_log_file is not None:
                try:
                    telemetry_log_file.write(json.dumps(payload) + "\n")
                except OSError as exc:
                    logger.warning("Failed to write telemetry log: %s", exc)
            try:
                udp_socket.sendto(json.dumps(payload).encode("utf-8"), udp_target)
            except OSError as exc:
                logger.warning("Failed to send UDP telemetry: %s", exc)

            if args.max_frames > 0 and frame_counter >= args.max_frames:
                logger.info("Reached max frame limit (%d); stopping.", args.max_frames)
                break
    except KeyboardInterrupt:
        logger.info("Interrupted by user. Shutting down.")
    finally:
        frame_provider.release()
        udp_socket.close()
        if telemetry_log_file is not None:
            telemetry_log_file.flush()
            telemetry_log_file.close()
        logger.info("LKAS vision node stopped.")


if __name__ == "__main__":
    main()
